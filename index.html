<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>SiteGuard — Debug Friendly</title>
<style>
:root{
  --bg:#020617;--border:#1e293b;--text:#e5e7eb;--muted:#94a3b8;
  --primary:#38bdf8;--accent:#0ea5e9;--ok:#4ade80;--warn:#facc15;--bad:#f87171;
}
*{box-sizing:border-box}
body{margin:0;font-family:system-ui;background:var(--bg);color:var(--text)}
.header{padding:16px 24px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between}
.container{max-width:1100px;margin:18px auto;padding:18px}
.input-row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
input{padding:10px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--text);min-width:300px}
.btn{padding:10px 14px;border-radius:8px;border:none;background:linear-gradient(90deg,var(--primary),var(--accent));color:#020617;cursor:pointer}
.card{border:1px solid var(--border);padding:12px;border-radius:10px;margin-top:12px}
.small{color:var(--muted);font-size:0.95rem}
.status{margin-top:12px;color:var(--muted);font-size:0.95rem}
.hidden{display:none}
.badge{display:inline-block;padding:6px 10px;border-radius:14px}
.ok{background:#052e1a;color:var(--ok)}
.warn{background:#3a2e05;color:var(--warn)}
.bad{background:#3a0505;color:var(--bad)}
.loading{display:inline-block;width:18px;height:18px;border:3px solid var(--border);border-top:3px solid var(--primary);border-radius:50%;animation:spin 1s linear infinite;vertical-align:middle;margin-left:8px}
@keyframes spin{to{transform:rotate(360deg)}}
.consoleBox{background:#071022;padding:10px;border-radius:8px;margin-top:12px;font-family:monospace;color:#9fb3d6;max-height:200px;overflow:auto}
</style>
</head>
<body>
<div class="header"><div style="font-weight:700">SiteGuard (Debug)</div><div class="small">Robust proxy attempts + visible logs</div></div>
<div class="container">

  <div class="card">
    <h2>Quick scan</h2>
    <div class="input-row">
      <input id="urlInput" placeholder="example.com or https://example.com">
      <button class="btn" id="runBtn">Analyze</button>
      <span id="loading" class="hidden loading" title="loading"></span>
    </div>
    <div id="status" class="status">Enter a domain and click Analyze.</div>
  </div>

  <div id="results" class="card hidden">
    <h3>Results</h3>
    <div class="small">URL: <span id="analyzedUrl"></span></div>
    <div style="margin-top:10px">
      <div>Score: <span id="scoreDisplay">0</span></div>
      <div class="small" id="fetchInfo"></div>
    </div>

    <div style="margin-top:12px">
      <div>HTTPS: <span id="httpsBadge" class="badge"></span></div>
      <div>Availability: <span id="upBadge" class="badge"></span></div>
      <div>Response (heuristic): <span id="timeNote" class="small"></span></div>
      <div>Mixed refs: <span id="mixedBadge" class="badge"></span></div>
      <div>URL hygiene: <span id="urlBadge" class="badge"></span></div>
      <div>CMS hints: <span id="cmsHints" class="small"></span></div>
    </div>

    <div style="margin-top:12px">
      <button class="btn" onclick="downloadReport()">Download PDF (basic)</button>
      <button class="btn" onclick="goPlans()">Unlock Advanced</button>
    </div>

    <div class="chat card">
      <strong>Security Copilot</strong>
      <div id="aiOutput" class="small" style="margin-top:8px">Run scan to get hints. Upgrade for step-by-step fixes.</div>
    </div>
  </div>

  <div class="card">
    <h3>Console (debug)</h3>
    <div id="console" class="consoleBox">logs will appear here...</div>
  </div>

  <div class="small" style="margin-top:12px;color:var(--muted)">
    Test examples: <code>neverssl.com</code> (HTTP-only) — should show Missing HTTPS; <code>wikipedia.org</code> (HTTPS) — should show OK.
  </div>
</div>

<script>
/* ---------- Helpers & state ---------- */
const el = id => document.getElementById(id)
const show = e => e && e.classList.remove('hidden')
const hide = e => e && e.classList.add('hidden')
const log = txt => { const c = el('console'); c.textContent = txt + "\n" + c.textContent; }

/* state */
let lastReport = null
let lastIssues = []
let isAdvanced = false

/* safe fetch via proxy attempts (tries multiple proxies) */
async function tryFetchWithProxies(target, timeout=7000){
  const proxies = [
    name => `https://api.allorigins.win/get?url=${encodeURIComponent(name)}`,
    name => `https://thingproxy.freeboard.io/fetch/${encodeURIComponent(name)}`
  ]
  for(const p of proxies){
    const url = p(target)
    log('[TRY] proxy -> ' + url)
    try{
      const controller = new AbortController()
      const id = setTimeout(()=>controller.abort(), timeout)
      const res = await fetch(url, { signal: controller.signal })
      clearTimeout(id)
      if(!res.ok) { log('[FAIL] proxy status ' + res.status); continue }
      // allorigins returns JSON with contents, thingproxy returns raw body (string)
      const ct = res.headers.get('content-type') || ''
      if(ct.includes('application/json')){
        const j = await res.json()
        if(j && j.contents) { log('[OK] proxy returned json contents'); return { ok:true, contents: j.contents, proxyUrl: url } }
      } else {
        const text = await res.text()
        if(text && text.length>0) { log('[OK] proxy returned raw text'); return { ok:true, contents: text, proxyUrl: url } }
      }
    }catch(err){
      log('[ERR] proxy fetch failed: ' + (err && err.message))
      // continue to next proxy
    }
  }
  return { ok:false, error:'all proxies failed' }
}

/* normalize input */
function normalize(raw){
  raw = (raw||'').trim()
  if(!raw) return null
  if(!/^https?:\/\//i.test(raw)) raw = 'https://' + raw
  try{ const u = new URL(raw); return { origin: u.origin, href: u.href, path: u.pathname + u.search } }
  catch(e){ return null }
}

/* ---------- Main scan flow ---------- */
async function scan(){
  const raw = el('urlInput').value
  const norm = normalize(raw)
  if(!norm){ alert('Digite uma URL válida'); return }

  // UI start
  el('console').textContent = ''
  log('Starting scan for ' + norm.href)
  hide(el('results'))
  show(el('loading'))
  el('status').textContent = 'Probing proxies to fetch site HTML...'

  lastReport = { url: norm.href, checks: {} }
  lastIssues = []

  // try HTTPS origin then http origin
  const httpsOrigin = norm.origin
  const httpOrigin = norm.origin.replace(/^https:/,'http:')

  // Try https origin via proxies
  let fetched = await tryFetchWithProxies(httpsOrigin)
  if(!fetched.ok){
    // try https full href
    log('https origin failed, trying https full href')
    fetched = await tryFetchWithProxies(norm.href)
  }
  if(!fetched.ok){
    log('https attempts failed, trying http origin')
    fetched = await tryFetchWithProxies(httpOrigin)
  }
  if(!fetched.ok){
    log('http origin failed, trying http full href')
    fetched = await tryFetchWithProxies(norm.href.replace(/^https:/,'http:'))
  }

  // determine results
  const using = fetched.ok ? fetched.proxyUrl.includes('http:') || fetched.proxyUrl.includes('thingproxy') ? 'fetched' : 'fetched' : null
  const content = fetched.ok ? fetched.contents : ''
  // availability
  const up = !!fetched.ok
  lastReport.checks.up = up
  // heuristic response time (approx)
  lastReport.checks.responseTimeMs = up ? Math.max(100, Math.min(3000, Math.round(content.length/600))) : 5000

  // hasHttps: detect if proxy fetch succeeded via https origin or https full
  // we check what we attempted first: if we got content when trying https origin/full -> assume HTTPS; otherwise http
  const hasHttps = (fetched.ok && (fetched.proxyUrl && fetched.proxyUrl.indexOf('https://')===0 && fetched.proxyUrl.includes('allorigins')===false) || fetched.proxyUrl && fetched.proxyUrl.includes('allorigins') && fetched.proxyUrl.includes('https://')) ? (fetched.proxyUrl.indexOf('https:')!==-1) : false
  // Simpler: check whether original input started with https and we could fetch via any proxy using https origin/full
  // We'll instead test by trying to fetch httpsOrigin specifically succeeded earlier
  // For clarity, recompute: if first successful attempt was with httpsOrigin or https full href, treat as HTTPS found.
  const wasHttpsAttempt = fetched.ok && (fetched.proxyUrl && (fetched.proxyUrl.indexOf(encodeURIComponent(httpsOrigin))!==-1 || fetched.proxyUrl.indexOf(encodeURIComponent(norm.href))!==-1) && norm.href.startsWith('https://'))
  // fallback simpler decision:
  const detectedHttps = fetched.ok && (/^https:/.test(norm.href)) && (fetched.ok && fetched.contents.length>0 && (fetched.proxyUrl && fetched.proxyUrl.includes('allorigins') || fetched.proxyUrl.includes('thingproxy')))
  // We'll compute final hasHttps as: try direct heuristic: if norm.href starts with https and we fetched something when trying https-origin/full -> true. Else false.
  let finalHasHttps = false
  if(fetched.ok){
    // quick heuristic: check lastReport.checks.fetchUsed by seeing whether we fetched httpOrigin or httpsOrigin in logs:
    finalHasHttps = fetched.proxyUrl && (fetched.proxyUrl.indexOf(encodeURIComponent(httpsOrigin)) !== -1 || fetched.proxyUrl.indexOf(encodeURIComponent(norm.href)) !== -1) && norm.href.startsWith('https://')
    // last fallback: if content contains 'https://' references and no 'http://' majority, assume https ok
    if(!finalHasHttps && content){
      if(content.includes('https://') && !content.includes('HTTP/1.1 301') ) finalHasHttps = norm.href.startsWith('https://')
    }
  }
  lastReport.checks.hasHttps = finalHasHttps

  // mixed content heuristic
  const mixedMatches = content ? (content.match(/http:\/\/[^"'>\s]+/gi) || []) : []
  lastReport.checks.mixedCount = mixedMatches.length

  // url hygiene
  lastReport.checks.urlHygiene = !(norm.href.includes('?') || norm.href.includes('%3C') || norm.href.includes('='))
  // cms hints
  const cmsHints = []
  if(content){
    const low = content.toLowerCase()
    if(low.includes('wp-content') || low.includes('wordpress')) cmsHints.push('WordPress')
    if(low.includes('drupal')) cmsHints.push('Drupal')
    if(low.includes('joomla')) cmsHints.push('Joomla')
    lastReport.checks.hasCSP = low.includes('content-security-policy')
  } else lastReport.checks.hasCSP = false
  lastReport.checks.cmsHints = cmsHints

  // score
  let score = 0
  if(lastReport.checks.hasHttps) score += 40
  if(lastReport.checks.up) score += 20
  if(lastReport.checks.responseTimeMs < 800) score += 20
  if(lastReport.checks.urlHygiene) score += 20
  lastReport.score = Math.min(100,score)

  // build issues
  lastIssues = []
  if(!lastReport.checks.hasHttps) lastIssues.push('No HTTPS detected — site should use TLS certificate.')
  if(!lastReport.checks.up) lastIssues.push('Site did not respond via proxy — may be down or blocking requests.')
  if(lastReport.checks.responseTimeMs > 800) lastIssues.push('Slow response time (>800ms).')
  if(!lastReport.checks.urlHygiene) lastIssues.push('URL contains query or suspicious tokens.')
  if(lastReport.checks.mixedCount > 0) lastIssues.push('Detected references to insecure (http://) resources (mixed content).')

  // update UI
  hide(el('loading'))
  show(el('results'))
  el('analyzedUrl').textContent = norm.href
  el('scoreDisplay').textContent = lastReport.score
  el('fetchInfo').textContent = fetched.ok ? 'Proxy used: ' + fetched.proxyUrl : 'No proxy could fetch the site.'
  el('httpsBadge').textContent = lastReport.checks.hasHttps ? 'OK' : 'Missing'
  el('httpsBadge').className = 'badge ' + (lastReport.checks.hasHttps ? 'ok' : 'bad')
  el('upBadge').textContent = lastReport.checks.up ? 'Online' : 'Offline'
  el('upBadge').className = 'badge ' + (lastReport.checks.up ? 'ok' : 'bad')
  el('timeNote').textContent = lastReport.checks.responseTimeMs + ' ms'
  el('mixedBadge').textContent = lastReport.checks.mixedCount>0 ? lastReport.checks.mixedCount + ' refs' : 'None'
  el('mixedBadge').className = 'badge ' + (lastReport.checks.mixedCount>0 ? 'warn' : 'ok')
  el('urlBadge').textContent = lastReport.checks.urlHygiene ? 'Clean' : 'Suspicious'
  el('urlBadge').className = 'badge ' + (lastReport.checks.urlHygiene ? 'ok' : 'warn')
  el('cmsHints').textContent = lastReport.checks.cmsHints.length ? lastReport.checks.cmsHints.join(', ') : 'None'

  // update copilot
  updateCopilot()
  log('Scan complete. Score: ' + lastReport.score)
}

/* download simple printable report */
function downloadReport(){
  if(!lastReport){ alert('Run a scan first'); return }
  const w = window.open('','_blank')
  const html = `<html><head><meta charset="utf-8"><title>Report</title></head><body><h1>SiteGuard Report</h1><p>URL: ${lastReport.url}</p><p>Score: ${lastReport.score}</p><pre>${JSON.stringify(lastReport, null, 2)}</pre><script>window.print()</script></body></html>`
  w.document.write(html); w.document.close()
}

/* minimal flow for plans */
function goPlans(){ alert('Plans — demo (no payment yet)') }

/* copilot (rule-based) */
function generateCopilotText(forAdvanced){
  if(!lastReport) return 'Execute a scan para receber orientações.'
  if(lastIssues.length===0) return 'Nenhuma falha crítica detectada.'
  if(!forAdvanced){
    const list = lastIssues.slice(0,3).map((i,idx)=>`${idx+1}. ${i.split('.')[0]}.`).join(' ')
    return `Problemas detectados: ${list} Atualize certificados e verifique performance. Faça upgrade para instruções passo-a-passo.`
  }
  return lastIssues.map((s, i)=>`${i+1}. ${s} — passo: veja logs e aplique fix X.`).join('\n\n')
}
function updateCopilot(){ el('aiOutput').innerText = generateCopilotText(isAdvanced) }

/* attach events */
el('runBtn').addEventListener('click', ()=>{
  // show loading indicator and clear previous console
  el('console').textContent = ''
  show(el('loading'))
  el('status').textContent = 'Starting scan...'
  setTimeout(scan, 200) // small delay so loading shows
})

/* init UI */
hide(el('results')); hide(el('loading')); el('status').textContent='Enter domain and click Analyze. Open Console (F12) if errors appear.'
</script>
</body>
</html>
